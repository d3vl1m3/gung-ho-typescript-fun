import PropsInterface from '@/classes/models/interfaces/PropsInterface';
import UserEntity from '@/classes/entities/UserEntity';

export default abstract class FormDataModelPropsFactoryAbstract<T extends PropsInterface> {

  /**
   * An array of strings that state what named fields are expected from the form
   */
  protected abstract _requiredFormFields: string[];

  /**
   * Apply any additional props that will be merged into and overwrite the props generated from the form.
   * Especially useful if not all props are generated by the form (e.g. Timestamps).
   */
  protected abstract _additionalProps: {} = {};

  /**
   * Will hold an example props interface of the required model type
   */
  protected abstract _requiredProps: T;

  private _props: T|null = null;
  private _form: HTMLFormElement;

  get props(): T|null {
    const generatedProps = this.generateProps();
    return this.hasRequiredFields() && generatedProps ? generatedProps : null;
  }
  set props(value: T | null) {
    this._props = value;
  }

  constructor(options: {form: HTMLFormElement}) {
    this._form = options.form;
  }


  private hasRequiredFields(): boolean {
    const elements = this._form.elements;
    for ( const requiredFormField of this._requiredFormFields ) {
      if ( !elements.namedItem(requiredFormField) ) {
        return false;
      }
    }
    return true;
  }

  private generateProps(): T | null {
    const elements = this._form.elements;
    const items: {[index: string]: any} = {};
    for ( const requiredFormField of this._requiredFormFields ) {
      const element = elements.namedItem(requiredFormField) as HTMLInputElement;
      if ( element ) {
        // todo: add a hook here for custom filter to be applied based on the element name from the sub class
        items[requiredFormField] = requiredFormField === 'author' ? UserEntity.find(element.value) : element.value;
      }
    }

    const finalObject = {...items, ...this._additionalProps};
    return this.compareObjects(finalObject) ? finalObject as T : null;
  }

  /**
   * Type guarding check to see if the the parsed object matches the expected keys
   * todo: Make sure the types match the required type.. may be problematic if it can be multiple type or optional
   */
  private compareObjects(object: {[index: string]: any}) {
    const requiredProp = Object.keys(this._requiredProps).sort();
    const compiledObject = Object.keys(object).sort();
    return JSON.stringify(requiredProp) === JSON.stringify(compiledObject);
  }
}
